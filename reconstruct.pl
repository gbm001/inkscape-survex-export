#!/usr/bin/env perl

use strict;
use warnings;

# Perl script to extract paths from SVG file and convert to survex.

# Copyright (C) 2015 Patrick B Warren.
# Email: patrickbwarren@gmail.com
# Paper mail: Dr Patrick B Warren, 11 Bryony Way, Birkenhead,
#   Merseyside, CH42 4LY, UK.

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see
# <http://www.gnu.org/licenses/>.

use XML::Parser;
use Getopt::Long;

my (@path_d, @path_id, @path_style, @path_layer);
my (@station_id, @station_x, @station_y);
my (@traverse_id, @traverse_legs, @traverse_start);
my (@leg, @xy, @equate, @export);
my %export_hash;

my ($s, $t, $ignore, $rest, $prev, $xy, $i, $j);
my ($x, $y, $dx, $dy, $len, $ex, $ey, $nx, $ny, $sf);
my ($traverse, $compass, $nstation, $ntraverse);

my $current_layer = "";

my $pi = 4*atan2(1, 1);
my $rad2deg = 180 / $pi;

my $opts = join(" ", @ARGV);

my $help = 0;
my $north = 0;
my $scale = 100;
my $tol = 0.2;
my $clino = 0;
my $name = "";
my $layer = "";
my $extra = 0;

my $help_text = <<END;

Options '[opts]':

--name=<name> : (re)names the outermost *begin and *end block
--scale=<length> : gives the length of the scale bar (default 100m);
--bearing=<degrees> : gives the bearing of the orientation line (default 0);
--tol=<tolerance> : the tolerance in m (default 0.2) to equate stations;
--layer=<name> : generate traverses only for paths belonging to that layer;
--extra : adds extra information to the survex output as comments.

The generated survex file is sent to stdout (terminal output), but can
be sent to a file instead using the standard redirection '>' operator.

To read from stdin use '-' instead of a file name.    

Usually the SVG file will be generated by tracing over a survey using
Inkscape as described below.  The following conventions are observed:

* red poly-line paths are converted to traverses in the survex file;
* a single green line path represents the orientation (default S to N);
* a single blue line path represents the scale bar;
* paths of any other color are ignored.

Traverses generated from red poly-lines are captured in separate
*begin and *end blocks in the survex file.  If an Inkscape layer is
specified by name using the option below, then only those paths
belonging to that layer are included (the orientation and scale bar
are picked up irrespective of the layer).  The SVG path id is used for
the block name, so traverses can be matched up to paths in
Inkscape. The survey as a whole is wrapped in an outer *begin and *end
block with a name either derived from the SVG file name, or from
the named layer if one is given, or set as an option.

Within each traverse, survey legs are generated in the format 
  *data normal from to tape compass clino.  
The 'from' and 'to' stations are generated automatically.  The 'tape'
length is generated using the scale bar line as reference (the true
length of the scale bar being specified as an option).  The 'compass'
bearing is generated using the orientation line as reference (the true
orientation can be specified as an option if it is not S to N).  The
'clino' reading is set to zero.

Survey stations that are within a certain distance of each other (the
tolerance can be set as an option) are given as an *equate list inside
the top level *begin and *end block.  Stations which feature in the
*equate list are automatically exported out of the underlying *begin
and *end blocks by the appropriate *export commands.

Care should be taken to avoid unusual directives in the 'd' attribute
which defines the path, which should start with (lowercase) 'm' and
just feature a list of relative moves.  Spurious 'M' and 'L'
directives can arise if the path has been constructed
non-sequentially.  Paths containing these will be rejected (with a
warning) by the reconstruct.pl script.  These paths can be edited
with the XML editor in Inkscape, although removing directives usually
makes the path nodes jump around.
    

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see
<http://www.gnu.org/licenses/>.

Copyright (C) 2015 Patrick B Warren.

END

;

# Takes a bearing and returns it as string in 000 format.

sub sprintd {
    my $b = $_[0];
    while ($b < 0) { $b += 360; }
    $b = int($b + 0.5);
    while ($b >= 360) { $b -= 360; }
    return sprintf("%03i", $b);
}

# Push station name and position onto stacks

sub push_station {
    my ($station, $x, $y) = @_[0..2];
    push(@station_x, $x);
    push(@station_y, $y);
    push(@station_id, $station);
}

# Function handle used to capture path info from XML parser.

sub start {
    my ($expat, $element, %attr) = @_;
    my ($d, $s, $id);
    
    if ($element eq 'g') {
	if (exists $attr{'inkscape:groupmode'} && 
	      $attr{'inkscape:groupmode'} eq 'layer') {
	    if (exists $attr{'inkscape:label'}) { 
		$current_layer = $attr{'inkscape:label'}; 
	    }
	}
    }

    if ($element eq 'path') {
	$d = $attr{d}; $id = $attr{id}; $s = $attr{style};
	$d =~ s/^m //;
	if ($d =~ /[a-zA-Z]/) {
	    print STDERR "Ignorning $id, which contained ", 
	      "unexpected directives\n";
	    print STDERR ' --> "', $attr{d}, '"', "\n";
	} else {
	    push(@path_d, $d);
	    push(@path_id, $id);
	    push(@path_style, $s);
	    push(@path_layer, $current_layer);
	}
    }
    
}

GetOptions ("help" => \$help, "extra" => \$extra, 
	    "bearing=f" => \$north, "tol=f" => \$tol, 
	    "scale=f" => \$scale, "clino=f" => \$clino, 
	    "layer=s" => \$layer, "name=s" => \$name);

if ($help) {
    print "Usage:\n\n";
    print "perl $0 [opts] myfile.svg\n";
    print "    (to send output to terminal stdout)\n\n";
    print "perl $0 [opts] myfile.svg > myfile.svx\n";
    print "    (capture in a file)\n";
    print $help_text;
    exit(0);
}

die "Usage: $0 <svgfile>\n" unless @ARGV;

my $file = $ARGV[0];

if ($file eq "-") { $file = "/dev/stdin"; } 
else { die "Didn't find $file\n" unless (-e $file); }

# Figure out a name for the top level block, if not set as an option.
# If the name is empty after all this, it is not used.

if ($name eq "") {
    if ($layer eq "") {
	if ($file ne "/dev/stdin") {
	    $name = $file; $name =~ s/.svg$//;
	}
    } else { 
	$name = $layer;
    }
}

# Parse the SVG file using the XML parser and above handler function.

my $p1 = new XML::Parser();
$p1->setHandlers(Start => \&start);
$p1->parsefile($file) or die "Error parsing $file\n";

# In the next sections we build all the data structures needed to
# write the survex file.

# Figure out the orientation vector (green is 00ff00)

for ($i=0; $i<@path_id; $i++) {
    last if ($path_style[$i] =~ /stroke:#00ff00/);
}

die "No green (stroke:#00ff00) orientation vector found\n" if ($i == @path_id);

# Construct the unit vector (nx, ny) to point along N, and the unit
# (ex, ey) to point along E.  We correct for the bearing later.
# The '0 +' trick (below) forces the result to a pure number.

($ignore, $xy) = split(/ +/, $path_d[$i], 2);
@xy = split(/,/, $xy, 2);
$dx = 0 + $xy[0]; $dy = 0 + $xy[1];
$len = sqrt($dx*$dx + $dy*$dy);
$nx = $dx / $len; $ny = $dy / $len;
$ex = - $ny; $ey = $nx;

# Figure out the scale vector (blue is 0000ff) and calculate scale factor

for ($i=0; $i<@path_id; $i++) {
    last if ($path_style[$i] =~ /stroke:#0000ff/);
}

die "No blue (stroke:#0000ff) scale bar found\n" if ($i == @path_id);

($ignore, $xy) = split(/ +/, $path_d[$i], 2);
@xy = split(/,/, $xy, 2);
$dx = 0 + $xy[0]; $dy = 0 + $xy[1];
$len = sqrt($dx*$dx + $dy*$dy);
$sf = $scale / $len;

# Now build the survex traverses.  The survex legs are collected as a
# multiline string.  Also keep track of stations and absolute (SVG)
# positions to identify equates and exports.

for ($i=0; $i<@path_id; $i++) {
    if ($path_style[$i] =~ /stroke:#ff0000/ &&
	   ($layer eq "" || $path_layer[$i] eq $layer)) {
	$traverse = $path_id[$i];
	push(@traverse_id, $traverse);
	@leg = split(/ +/, $path_d[$i]);
	@xy = split(/,/, $leg[0], 2);
	$x = 0 + $xy[0]; $y = 0 + $xy[1];
	push_station("$traverse.0", $x, $y);
	push(@traverse_start, "($x, $y)");
	$s = "";
	for ($j=1; $j<@leg; $j++) {
	    @xy = split(/,/, $leg[$j], 2);
	    $dx = 0 + $xy[0]; $dy = 0 + $xy[1];
	    $x += $dx; $y += $dy;
	    push_station("$traverse.$j", $x, $y);
	    $len = sqrt($dx*$dx + $dy*$dy);
	    $s .= sprintf("%3i ", $j-1); # from
	    $s .= sprintf("%3i ", $j); # to
	    $s .= sprintf("%7.2f  ", $sf*$len); # tape
	    $compass = $north + $rad2deg * 
		atan2($ex*$dx + $ey*$dy, $nx*$dx + $ny*$dy);
	    $s .= sprintd($compass); # compass
	    $s .= "  $clino "; # clino
	    if ($extra) { $s .= "; SVG vector ($dx, $dy)\n"; }
	    else { $s .= "\n"; }
	}
	push(@traverse_legs, $s);
    }
}

$ntraverse = scalar @traverse_id;
$nstation = scalar @station_id;

# Identify the equates.  This is an O(n^2) pairwise comparison and
# more efficient methods are available but n should not get too large:
# for a large project it almost always bound to be a good idea to
# break the survey up into manageable chunks, each of which can be
# allocated its own survex file.  This can be facilitated by putting
# different sections into different inkscape layers.

if ($nstation > 1) {
    for ($i=0; $i<$nstation-1; $i++) {
	for ($j=$i+1; $j<$nstation; $j++) {
	    $dx = $station_x[$i] - $station_x[$j];
	    $dy = $station_y[$i] - $station_y[$j];
	    $len = $sf * sqrt($dx*$dx + $dy*$dy);
	    if ($len < $tol) {
		$s = "*equate " . $station_id[$i] . " ";
		$s .= $station_id[$j] . " ; ";
		$s .= sprintf("separation %4.2f m", $len);
		push(@equate, $s);
	    }
	}
    }
}

# Afficianados will notice this is a job only half done.  What we have
# generated is an (incomplete) list of equivalence relations between
# stations.  It may be incomplete because if A is near B, and B is
# near C, it doesn't always follow that A is near enough C to satisfy
# the closeness criterion.  What we should really do next is build the
# set of equivalence classes of stations, then we can generate
# precisely n-1 *equate directives for each non trivial equivalence
# class of size n > 1.  In fact, survex allows for mutiple stations to
# be listed in one *equate line, so we could just generate one *equate
# directive for each non trivial equivalence class.  However survex
# doesn't complain if there is redundant information in the equate
# directives so below we take the easy option of using the list of
# equivalence relations to generate a 1:1 list of equate directives.
# Fastidiuous people may wish to tidy this up by hand afterwards.

# Extract the list of stations required for export from the list of
# equates.

for ($i=0; $i<@equate; $i++) {
    ($ignore, $s, $t, $rest) = split(/ /, $equate[$i], 4);
    push(@export, $s); push(@export, $t);
}

# Sorting the list ensures the stations are in traverse order and
# duplicates can be identified.  We use a hash to keep track of
# stations which should be exported from a given traverse.

@export = sort @export; 

$prev = "";

for ($i=0; $i<@export; $i++) {
    next if ($export[$i] eq $prev); # skip duplicates
    ($s, $t) = split(/\./, $export[$i]);
    if (exists $export_hash{$s}) { $export_hash{$s} .= " $t"; }
    else { $export_hash{$s} = $t; }
    $prev = $export[$i]; 
}

# Now we are in a position to write the survex file.

print "; survex file autogenerated from $file\n";
print "; command: $0 $opts\n";
print "; generated ", scalar localtime(), "\n\n";

print "; SVG orientation: ($nx, $ny) is ", sprintd($north), " and";
print " ($ex, $ey) is ", sprintd($north + 90), "\n";
print "; SVG scale: $len is $scale" . "m (scale factor $sf)\n";
print "; SVG contained $ntraverse traverses and $nstation stations\n";
print "; tolerance for identifying equates = $tol m\n\n";

print "*data normal from to tape compass clino\n\n";

print "*begin $name\n\n" unless ($name eq "");

for ($i=0; $i<@equate; $i++) {
    print $equate[$i], "\n";
}

for ($i=0; $i<@traverse_id; $i++) {
    $s = $traverse_id[$i];
    print "\n*begin $s";
    if ($extra) { 
	print "         ; ";
	print "SVG start position ", $traverse_start[$i];
    }
    print "\n";
    if (exists $export_hash{$s}){
	print "*export ", $export_hash{$s}, "\n";
    }
    print $traverse_legs[$i];
    print "*end ", $traverse_id[$i], "\n";
}

print "\n*end $name\n" unless ($name eq "");

if ($extra) {
    
    print "\n";
    
    for ($i=0; $i<$nstation; $i++) {
	print "; station ", $station_id[$i];
	print " absolute SVG position (", $station_x[$i];
	print ", ", $station_y[$i], ")\n";
    }

    print "\n; end of file\n";

}

# end of perl script
